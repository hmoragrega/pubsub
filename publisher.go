package pubsub

import (
	"context"
	"fmt"
)

// Publisher describes the top level method to publish messages.
type Publisher interface {
	Publish(ctx context.Context, topic string, message Message) error
}

// EnvelopePublisher publish envelopes where the data has already been
// marshalled.
//
// You can also use this interface directly is you want to handle the
// marshalling yourself, combined with the NoOpMarshaller for the
// router.
type EnvelopePublisher interface {
	Publish(ctx context.Context, topic string, envelope Envelope) error
}

// Envelope holds the data that need to be transmitted.
type Envelope struct {
	ID         MessageID
	Name       string
	Key        string
	Body       []byte
	Version    string
	Attributes Attributes
}

// StdPublisher will marshall a message and publish a message
// delegate the publishing of the envelope.
type StdPublisher struct {
	Publisher  EnvelopePublisher
	Marshaller Marshaller
}

// Publish a message to the given topic.
func (p *StdPublisher) Publish(ctx context.Context, topic string, message Message) error {
	body, version, err := p.Marshaller.Marshal(message.Data)
	if err != nil {
		return fmt.Errorf("marshaller error: %w", err)
	}

	id := message.ID
	if len(message.ID) == 0 {
		id = NewID()
	}

	return p.Publisher.Publish(ctx, topic, Envelope{
		ID:         id,
		Name:       message.Name,
		Key:        message.Key,
		Attributes: message.Attributes,
		Body:       body,
		Version:    version,
	})
}

// PublisherHandler handles events and generates new
// messages that should be published.
type PublisherHandler interface {
	HandleMessage(ctx context.Context, message *Message) ([]*Message, error)
}

// PublisherHandlerFunc function that can handle a message.
type PublisherHandlerFunc func(ctx context.Context, message *Message) ([]*Message, error)

// HandleMessage handles the message with the function.
func (f PublisherHandlerFunc) HandleMessage(ctx context.Context, message *Message) ([]*Message, error) {
	return f(ctx, message)
}

// Handler is a helper that publishes messages generated by other handlers.
func (p *StdPublisher) Handler(topic string, handler PublisherHandler) Handler {
	return HandlerFunc(func(ctx context.Context, message *Message) error {
		messages, err := handler.HandleMessage(ctx, message)
		if err != nil {
			return err
		}
		for _, m := range messages {
			if err := p.Publish(ctx, topic, *m); err != nil {
				return err
			}
		}
		return nil
	})
}
