package pubsub

import (
	"context"
	"errors"
	"fmt"
)

var ErrMissingHandler = errors.New("missing handler")

// MessageHandler handles events.
type MessageHandler interface {
	HandleMessage(ctx context.Context, message *Message) error
}

// MessageHandlerFunc that handles an event
type MessageHandlerFunc func(ctx context.Context, message *Message) error

func (f MessageHandlerFunc) HandleMessage(ctx context.Context, message *Message) error {
	return f(ctx, message)
}

// HandlerResolver is able to return the correct
// handler for a received message
type HandlerResolver interface {
	// Resolve return the message handler. If it does not
	// now the handler it will return false in the second
	// parameter.
	Resolve(message ReceivedMessage) (MessageHandler, bool)
}

type HandlerResolverFunc func(message ReceivedMessage) (MessageHandler, bool)

func (f HandlerResolverFunc) Resolve(message ReceivedMessage) (MessageHandler, bool) {
	return f(message)
}

// Dispatcher is a message handler middleware that can be used to register
// different handlers for the same topic, based on the event name.
func Dispatcher(handlers map[string]MessageHandler) MessageHandlerFunc {
	return func(ctx context.Context, message *Message) error {
		h, ok := handlers[message.Name]
		if !ok {
			return fmt.Errorf("%w: %s", ErrMissingHandler, message.Name)
		}
		return h.HandleMessage(ctx, message)
	}
}

type PublisherMessageHandler interface {
	HandleMessage(ctx context.Context, message *Message) (*Message, error)
}

type PublisherHandler struct {
	Publisher Publisher
}

// Wrap generates a message handler middleware that
// will publish the messages generated by the handler.
func (p *PublisherHandler) Wrap(topic string, handler PublisherMessageHandler) MessageHandler {
	return MessageHandlerFunc(func(ctx context.Context, message *Message) error {
		msg, err := handler.HandleMessage(ctx, message)
		if err != nil {
			return err
		}
		if msg != nil {
			return p.Publisher.Publish(ctx, topic, *msg)
		}
		return nil
	})
}
